function [ data ] = extendData( data, targetDegree, alphaPar )
%EXTENDDATA function extends the struct data generated by matricesToStruct, 
% with the improvement of input and output configurations such thath 
% new set of drivers and sensors ensure the relative degree given by
% targetDegree. Configurations qualified by a cost function that uses an
% alpha parameter.
% Input: data, generated by function matricesToStruct.
%        targetDegree: order of the system that is acceptable.
%        alphaPar: alpha parameter of cost function. 
%                  More detail in: Sensors, 18(9), 3096.
% Output: the extended data with the following field
% data.
%    improved.
%       targetDegree
%       actCov
%       senCov
%       actCovRet
%       senCovRet
%       actNetMesRet
%       senNetMesRet
%       actCovSize
%       senCovSize
%       actCovRetSize
%       senCovRetSize
%       actNetMesRetSize
%       senNetMesRetSize
%       actCovCost
%       senCovCost
%       actCovRetCost
%       senCovRetCost
%       actNetMesRetCost
%       senNetMesRetCost
%       actCovMax
%       senCovMax
%       actCovRetMax
%       senCovRetMax
%       actNetMesRetMax
%       senNetMesRetMax
%       actCovMean
%       senCovMean
%       actCovRetMean
%       senCovRetMean
%       actNetMesRetMean
%       senNetMesRetMean
%       actmCLASA
%       senmCLASA
%       actGDFCMSA
%       senGDFCMSA
%       actmCLASASize
%       senmCLASASize
%       actGDFCMSASize
%       senGDFCMSASize
%       actmCLASACost
%       senmCLASACost
%       actGDFCMSACost
%       senGDFCMSACost
%       actmCLASAMax
%       senmCLASAMax
%       actGDFCMSAMax
%       senGDFCMSAMax
%       actmCLASAMean
%       senmCLASAMean
%       actGDFCMSAMean
%       senGDFCMSAMean
% ##################
% Example:
% ##################
% Inputs:
%
% data = matricesToStruct(Amatrix,Bmatrix,Cmatrix,Dmatrix,mesConfig); % see more in matricesToStruct 
% targetDegree = data.system.measure.diameter/2;
% alphaPar = 0.5;
% ##################
% Function Calling:
% 
% [data] = extendData(data, targetDegree, alphaPar);
% ##################
% Output:
%
% data = 
%       system: [1x1 struct]
%         node: [1x1 struct]
%         edge: [1x1 struct]
%     improved: [1x1 struct]
% ##################
%  The algorithm was implemented by Daniel Leitold 
  
if ~exist('allShortestPaths', 'file')
   mfilepath=fileparts(which('extendData'));
   addpath([mfilepath,'\..\module2']);
end

% get the adjacency matrix (not state transition)
adj = data.system.describe.effectGraph;

% If the adjacency is sparse then convert
if issparse(adj)
    adj = full(adj);
end

%% targetOrder & actCovSize & actCovSizeRet & senCovSize &
%% senCovSizeRet & actNetMesSizeRet & senNetMesSizeRet
% target order is the fourt of diameter
N=data.system.measure.numOfNodes;
distsAct=allShortestPaths(adj);
distsAct(distsAct==Inf) = N; %replace with the max distance (just for numerical ..)
distsSen = distsAct';

[actCovSet, actCovRetSet, senCovSet, senCovRetSet, actNetMesRetSet, senNetMesRetSet] = ...
    evolveOperability(adj, targetDegree);
actCov = actCovSet;
actCovRet = actCovRetSet;
senCov = senCovSet;
senCovRet = senCovRetSet;
actNetMesRet = actNetMesRetSet;
senNetMesRet = senNetMesRetSet;

[actCovCost, actCovMax, actCovMean] = getCost(actCovSet, alphaPar, distsAct);
[actCovRetCost, actCovRetMax, actCovRetMean] = getCost(actCovRetSet, alphaPar, distsAct);
[actNetMesRetCost, actNetMesRetMax, actNetMesRetMean] = getCost(actNetMesRetSet, alphaPar, distsAct);

[senCovCost, senCovMax, senCovMean] = getCost(senCovSet, alphaPar, distsSen);
[senCovRetCost, senCovRetMax, senCovRetMean] = getCost(senCovRetSet, alphaPar, distsSen);
[senNetMesRetCost, senNetMesRetMax, senNetMesRetMean] = getCost(senNetMesRetSet, alphaPar, distsSen);

actCovSize = length(actCovSet);
actCovRetSize = length(actCovRetSet);
senCovSize = length(senCovSet);
senCovRetSize = length(senCovRetSet);
actNetMesRetSize = length(actNetMesRetSet);
senNetMesRetSize = length(senNetMesRetSet);


%% mCLASA & GDFCMSA
% number of iteration of Simulated Annealing
Niter = 500;
% number of independent runs
Nf = 10;

% driver nodes
actmCLASA = mCLASArMax(adj, targetDegree, Niter, Nf);
actmCLASASize = length(actmCLASA);
[actmCLASACost, actmCLASAMax, actmCLASAMean] = getCost(actmCLASA, alphaPar, distsAct);

actGDFCMSA = GDFCMSArMax(adj, targetDegree, Niter, Nf);
actGDFCMSASize = length(actGDFCMSA);
[actGDFCMSACost, actGDFCMSAMax, actGDFCMSAMean] = getCost(actGDFCMSA, alphaPar, distsAct);


% sensor nodes
senmCLASA = mCLASArMax(adj', targetDegree, Niter, Nf);
senmCLASASize = length(senmCLASA);
[senmCLASACost, senmCLASAMax, senmCLASAMean] = getCost(senmCLASA, alphaPar, distsSen);

senGDFCMSA = GDFCMSArMax(adj', targetDegree, Niter, Nf);
senGDFCMSASize = length(senGDFCMSA);
[senGDFCMSACost, senGDFCMSAMax, senGDFCMSAMean] = getCost(senGDFCMSA, alphaPar, distsSen);
clear DAEA;
clear distsAct;
clear distsSen;
clear alpha;
clear N;

%% Creating result
data.improved = struct(...
    'targetDegree', targetDegree,...
    'actCov', actCov,...                        % controllability is not granted
    'senCov', senCov,...                        % observability is not granted
    'actCovRet', actCovRet,...
    'senCovRet', senCovRet,...
    'actNetMesRet', actNetMesRet,...
    'senNetMesRet', senNetMesRet,...
    'actCovSize', actCovSize,...
    'senCovSize', senCovSize,...
    'actCovRetSize', actCovRetSize,...
    'senCovRetSize', senCovRetSize,...
    'actNetMesRetSize', actNetMesRetSize,...
    'senNetMesRetSize', senNetMesRetSize,...
    'actCovCost', actCovCost,...
    'senCovCost', senCovCost,...
    'actCovRetCost', actCovRetCost,...
    'senCovRetCost', senCovRetCost,...
    'actNetMesRetCost', actNetMesRetCost,...
    'senNetMesRetCost', senNetMesRetCost,...
    'actCovMax', actCovMax,...
    'senCovMax', senCovMax,...
    'actCovRetMax', actCovRetMax,...
    'senCovRetMax', senCovRetMax,...
    'actNetMesRetMax', actNetMesRetMax,...
    'senNetMesRetMax', senNetMesRetMax,...
    'actCovMean', actCovMean,...
    'senCovMean', senCovMean,...
    'actCovRetMean', actCovRetMean,...
    'senCovRetMean', senCovRetMean,...
    'actNetMesRetMean', actNetMesRetMean,...
    'senNetMesRetMean', senNetMesRetMean,...
    'actmCLASA', actmCLASA,...  
    'senmCLASA', senmCLASA,...
    'actGDFCMSA', actGDFCMSA,...  
    'senGDFCMSA', senGDFCMSA,...
    'actmCLASASize', actmCLASASize,...  
    'senmCLASASize', senmCLASASize,...
    'actGDFCMSASize', actGDFCMSASize,...  
    'senGDFCMSASize', senGDFCMSASize,...
    'actmCLASACost', actmCLASACost,...  
    'senmCLASACost', senmCLASACost,...
    'actGDFCMSACost', actGDFCMSACost,...  
    'senGDFCMSACost', senGDFCMSACost,...
    'actmCLASAMax', actmCLASAMax,...  
    'senmCLASAMax', senmCLASAMax,...
    'actGDFCMSAMax', actGDFCMSAMax,...  
    'senGDFCMSAMax', senGDFCMSAMax,...
    'actmCLASAMean', actmCLASAMean,...  
    'senmCLASAMean', senmCLASAMean,...
    'actGDFCMSAMean', actGDFCMSAMean,...  
    'senGDFCMSAMean', senGDFCMSAMean);

end

